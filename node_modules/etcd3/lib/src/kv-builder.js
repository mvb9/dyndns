"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RPC = require("./rpc");
const util_1 = require("./util");
const zeroKey = new Buffer([0]);
/**
 * prefixStart returns a buffer to start the key as a prefix.
 */
function prefixStart(key) {
    if (key.length === 0) {
        return zeroKey;
    }
    return toBuffer(key);
}
exports.prefixStart = prefixStart;
/**
 * prefixEnd returns the end of a range request, where `key` is the "start"
 * value, to get all values that share the prefix.
 */
function prefixEnd(key) {
    if (key.equals(zeroKey)) {
        return zeroKey;
    }
    let buffer = Buffer.from(key); // copy to prevent mutation
    for (let i = buffer.length - 1; i >= 0; i -= 0) {
        if (buffer[i] < 0xff) {
            buffer[i] = buffer[i] + 1;
            buffer = buffer.slice(0, i + 1);
            return buffer;
        }
    }
    return zeroKey;
}
exports.prefixEnd = prefixEnd;
/**
 * Converts the input to a buffer, if it is not already.
 */
function toBuffer(input) {
    if (input instanceof Buffer) {
        return input;
    }
    return Buffer.from(input);
}
exports.sortMap = {
    key: RPC.SortTarget.KEY,
    version: RPC.SortTarget.VERSION,
    createdAt: RPC.SortTarget.CREATE,
    modifiedAt: RPC.SortTarget.MOD,
    value: RPC.SortTarget.VALUE,
};
/**
 * RangeBuilder is a primitive builder for range queries on the kv store.
 * It's extended by the Single and MultiRangeBuilders, which contain
 * the concrete methods to execute the built query.
 */
class RangeBuilder extends util_1.PromiseWrap {
    constructor() {
        super(...arguments);
        this.request = {};
    }
    /**
     * revision is the point-in-time of the key-value store to use for the range.
     */
    revision(rev) {
        this.request.revision = rev;
        return this;
    }
    /**
     * serializable sets the range request to use serializable member-local reads.
     */
    serializable(serializable) {
        this.request.serializable = serializable;
        return this;
    }
    /**
     * minModRevision sets the minimum modified revision of keys to return.
     */
    minModRevision(minModRevision) {
        this.request.min_mod_revision = minModRevision;
        return this;
    }
    /**
     * maxModRevision sets the maximum modified revision of keys to return.
     */
    maxModRevision(maxModRevision) {
        this.request.max_mod_revision = maxModRevision;
        return this;
    }
    /**
     * minCreateRevision sets the minimum create revision of keys to return.
     */
    minCreateRevision(minCreateRevision) {
        this.request.min_create_revision = minCreateRevision;
        return this;
    }
    /**
     * maxCreateRevision sets the maximum create revision of keys to return.
     */
    maxCreateRevision(maxCreateRevision) {
        this.request.max_create_revision = maxCreateRevision;
        return this;
    }
}
exports.RangeBuilder = RangeBuilder;
/**
 * SingleRangeBuilder is a query builder that looks up a single key.
 */
class SingleRangeBuilder extends RangeBuilder {
    constructor(kv, key) {
        super();
        this.kv = kv;
        this.request.key = toBuffer(key);
        this.request.limit = 1;
    }
    /**
     * Runs the built request and parses the returned key as JSON,
     * or returns `null` if it isn't found.
     */
    json() {
        return this.string().then(JSON.parse);
    }
    /**
     * Runs the built request and returns the value of the returned key as a
     * string, or `null` if it isn't found.
     */
    string(encoding = 'utf8') {
        return this.exec().then(res => res.kvs.length === 0 ? null : res.kvs[0].value.toString(encoding));
    }
    /**
     * Runs the built request and returns the value of the returned key as a
     * buffer, or `null` if it isn't found.
     */
    buffer() {
        return this.exec().then(res => res.kvs.length === 0 ? null : res.kvs[0].value);
    }
    /**
     * Runs the built request and returns the raw response from etcd.
     */
    exec() {
        return this.kv.range(this.request);
    }
}
exports.SingleRangeBuilder = SingleRangeBuilder;
/**
 * MultiRangeBuilder is a query builder that looks up multiple keys.
 */
class MultiRangeBuilder extends RangeBuilder {
    constructor(kv) {
        super();
        this.kv = kv;
        this.prefix('');
    }
    /**
     * Prefix instructs the query to scan for all keys that have the provided prefix.
     */
    prefix(value) {
        this.request.key = prefixStart(value);
        this.request.range_end = prefixEnd(this.request.key);
        return this;
    }
    /**
     * All will instruct etcd to get all keys.
     */
    all() {
        return this.prefix('');
    }
    /**
     * inRange instructs the builder to get keys in the specified byte range.
     */
    inRange(start, end) {
        this.request.key = toBuffer(start);
        this.request.range_end = toBuffer(end);
        return this;
    }
    /**
     * Limit sets the maximum number of results to retrieve.
     */
    limit(count) {
        this.request.limit = isFinite(count) ? count : 0;
        return this;
    }
    /**
     * Sort specifies how the result should be sorted.
     */
    sort(target, order) {
        this.request.sort_target = exports.sortMap[target];
        this.request.sort_order = order.toLowerCase() === 'asc' ? RPC.SortOrder.ASCEND : RPC.SortOrder.DESCEND;
        return this;
    }
    /**
     * count returns the number of keys that match the query.
     */
    count() {
        this.request.count_only = true;
        return this.exec().then(res => Number(res.count));
    }
    /**
     * Keys instructs the query to get only the matching keys, not values.
     * json(), strings(), and buffers() will return the keys instead of values
     * when this is called.
     */
    keys() {
        this.request.keys_only = true;
        return this;
    }
    /**
     * Runs the built request and parses the returned keys as JSON.
     */
    json() {
        return this.buffers().then(res => res.map(value => JSON.parse(value.toString())));
    }
    /**
     * Runs the built request and returns the value of the returned key as a
     * string, or `null` if it isn't found.
     */
    strings(encoding = 'utf8') {
        return this.buffers().then(res => res.map(value => value.toString(encoding)));
    }
    /**
     * Runs the built request and returns the value of the returned key as a
     * buffers.
     */
    buffers() {
        return this.exec().then(res => res.kvs.map(kv => this.request.keys_only ? kv.key : kv.value));
    }
    /**
     * Runs the built request and returns the raw response from etcd.
     */
    exec() {
        return this.kv.range(this.request);
    }
}
exports.MultiRangeBuilder = MultiRangeBuilder;
/**
 * DeleteBuilder builds a deletion.
 */
class DeleteBuilder extends util_1.PromiseWrap {
    constructor(kv) {
        super();
        this.kv = kv;
        this.request = {};
    }
    /**
     * key sets a single key to be deleted.
     */
    key(value) {
        this.request.key = toBuffer(value);
        this.request.range_end = undefined;
        return this;
    }
    /**
     * Prefix instructs the query to delete all keys that have the provided prefix.
     */
    prefix(value) {
        this.request.key = prefixStart(value);
        this.request.range_end = prefixEnd(this.request.key);
        return this;
    }
    /**
     * All will instruct etcd to wipe all keys.
     */
    all() {
        return this.prefix('');
    }
    /**
     * inRange instructs the builder to delete keys in the specified byte range.
     */
    inRange(start, end) {
        this.request.key = toBuffer(start);
        this.request.range_end = toBuffer(end);
        return this;
    }
    /**
     * getPrevious instructs etcd to *try* to get the previous value of the
     * key before setting it. One may not always be available if a compaction
     * takes place.
     */
    getPrevious() {
        this.request.prev_kv = true;
        return this.exec().then(res => res.prev_kvs);
    }
    /**
     * exec runs the delete put request.
     */
    exec() {
        return this.kv.deleteRange(this.request);
    }
}
exports.DeleteBuilder = DeleteBuilder;
/**
 * PutBuilder builds a "put" request to etcd.
 */
class PutBuilder extends util_1.PromiseWrap {
    constructor(kv, key) {
        super();
        this.kv = kv;
        this.request = {};
        this.request.key = toBuffer(key);
    }
    /**
     * value sets the value that will be stored in the key.
     */
    value(value) {
        this.request.value = toBuffer(value);
        return this;
    }
    /**
     * Sets the lease value to use for storing the key. You usually don't
     * need to use this directly, use `client.lease()` instead!
     */
    lease(lease) {
        this.request.lease = lease;
        return this;
    }
    /**
     * Updates the key on its current lease, regardless of what that lease is.
     */
    ignoreLease() {
        this.request.ignore_lease = true;
        return this;
    }
    /**
     * getPrevious instructs etcd to *try* to get the previous value of the
     * key before setting it. One may not always be available if a compaction
     * takes place.
     */
    getPrevious() {
        this.request.prev_kv = true;
        return this.exec().then(res => (Object.assign({}, res.prev_kv, { header: res.header })));
    }
    /**
     * Touch updates the key's revision without changing its value. This is
     * equivalent to the etcd 'ignore value' flag.
     */
    touch() {
        this.request.value = undefined;
        this.request.ignore_value = true;
        return this.exec();
    }
    /**
     * exec runs the put request.
     */
    exec() {
        return this.kv.put(this.request);
    }
}
exports.PutBuilder = PutBuilder;
