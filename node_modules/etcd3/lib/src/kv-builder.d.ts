/// <reference types="node" />
import * as RPC from './rpc';
import { PromiseWrap } from './util';
/**
 * prefixStart returns a buffer to start the key as a prefix.
 */
export declare function prefixStart(key: Buffer | string): Buffer;
/**
 * prefixEnd returns the end of a range request, where `key` is the "start"
 * value, to get all values that share the prefix.
 */
export declare function prefixEnd(key: Buffer): Buffer;
export declare const sortMap: {
    key: RPC.SortTarget;
    version: RPC.SortTarget;
    createdAt: RPC.SortTarget;
    modifiedAt: RPC.SortTarget;
    value: RPC.SortTarget;
};
/**
 * RangeBuilder is a primitive builder for range queries on the kv store.
 * It's extended by the Single and MultiRangeBuilders, which contain
 * the concrete methods to execute the built query.
 */
export declare abstract class RangeBuilder extends PromiseWrap<RPC.IRangeResponse> {
    protected request: RPC.IRangeRequest;
    /**
     * revision is the point-in-time of the key-value store to use for the range.
     */
    revision(rev: number | string): this;
    /**
     * serializable sets the range request to use serializable member-local reads.
     */
    serializable(serializable: boolean): this;
    /**
     * minModRevision sets the minimum modified revision of keys to return.
     */
    minModRevision(minModRevision: number | string): this;
    /**
     * maxModRevision sets the maximum modified revision of keys to return.
     */
    maxModRevision(maxModRevision: number | string): this;
    /**
     * minCreateRevision sets the minimum create revision of keys to return.
     */
    minCreateRevision(minCreateRevision: number | string): this;
    /**
     * maxCreateRevision sets the maximum create revision of keys to return.
     */
    maxCreateRevision(maxCreateRevision: number | string): this;
}
/**
 * SingleRangeBuilder is a query builder that looks up a single key.
 */
export declare class SingleRangeBuilder extends RangeBuilder {
    private kv;
    constructor(kv: RPC.KVClient, key: string | Buffer);
    /**
     * Runs the built request and parses the returned key as JSON,
     * or returns `null` if it isn't found.
     */
    json(): Promise<object>;
    /**
     * Runs the built request and returns the value of the returned key as a
     * string, or `null` if it isn't found.
     */
    string(encoding?: string): Promise<string | null>;
    /**
     * Runs the built request and returns the value of the returned key as a
     * buffer, or `null` if it isn't found.
     */
    buffer(): Promise<Buffer | null>;
    /**
     * Runs the built request and returns the raw response from etcd.
     */
    exec(): Promise<RPC.IRangeResponse>;
}
/**
 * MultiRangeBuilder is a query builder that looks up multiple keys.
 */
export declare class MultiRangeBuilder extends RangeBuilder {
    private kv;
    constructor(kv: RPC.KVClient);
    /**
     * Prefix instructs the query to scan for all keys that have the provided prefix.
     */
    prefix(value: string | Buffer): this;
    /**
     * All will instruct etcd to get all keys.
     */
    all(): this;
    /**
     * inRange instructs the builder to get keys in the specified byte range.
     */
    inRange(start: string | Buffer, end: string | Buffer): this;
    /**
     * Limit sets the maximum number of results to retrieve.
     */
    limit(count: number): this;
    /**
     * Sort specifies how the result should be sorted.
     */
    sort(target: keyof typeof sortMap, order: 'asc' | 'desc'): this;
    /**
     * count returns the number of keys that match the query.
     */
    count(): Promise<number>;
    /**
     * Keys instructs the query to get only the matching keys, not values.
     * json(), strings(), and buffers() will return the keys instead of values
     * when this is called.
     */
    keys(): this;
    /**
     * Runs the built request and parses the returned keys as JSON.
     */
    json(): Promise<object>;
    /**
     * Runs the built request and returns the value of the returned key as a
     * string, or `null` if it isn't found.
     */
    strings(encoding?: string): Promise<string[]>;
    /**
     * Runs the built request and returns the value of the returned key as a
     * buffers.
     */
    buffers(): Promise<Buffer[]>;
    /**
     * Runs the built request and returns the raw response from etcd.
     */
    exec(): Promise<RPC.IRangeResponse>;
}
/**
 * DeleteBuilder builds a deletion.
 */
export declare class DeleteBuilder extends PromiseWrap<RPC.IDeleteRangeResponse> {
    private kv;
    private request;
    constructor(kv: RPC.KVClient);
    /**
     * key sets a single key to be deleted.
     */
    key(value: string | Buffer): this;
    /**
     * Prefix instructs the query to delete all keys that have the provided prefix.
     */
    prefix(value: string | Buffer): this;
    /**
     * All will instruct etcd to wipe all keys.
     */
    all(): this;
    /**
     * inRange instructs the builder to delete keys in the specified byte range.
     */
    inRange(start: string | Buffer, end: string | Buffer): this;
    /**
     * getPrevious instructs etcd to *try* to get the previous value of the
     * key before setting it. One may not always be available if a compaction
     * takes place.
     */
    getPrevious(): Promise<RPC.IKeyValue[]>;
    /**
     * exec runs the delete put request.
     */
    exec(): Promise<RPC.IDeleteRangeResponse>;
}
/**
 * PutBuilder builds a "put" request to etcd.
 */
export declare class PutBuilder extends PromiseWrap<RPC.IPutResponse> {
    private kv;
    private request;
    constructor(kv: RPC.KVClient, key: string | Buffer);
    /**
     * value sets the value that will be stored in the key.
     */
    value(value: string | Buffer): this;
    /**
     * Sets the lease value to use for storing the key. You usually don't
     * need to use this directly, use `client.lease()` instead!
     */
    lease(lease: number | string): this;
    /**
     * Updates the key on its current lease, regardless of what that lease is.
     */
    ignoreLease(): this;
    /**
     * getPrevious instructs etcd to *try* to get the previous value of the
     * key before setting it. One may not always be available if a compaction
     * takes place.
     */
    getPrevious(): Promise<RPC.IKeyValue & {
        header: RPC.IResponseHeader;
    }>;
    /**
     * Touch updates the key's revision without changing its value. This is
     * equivalent to the etcd 'ignore value' flag.
     */
    touch(): Promise<RPC.IPutResponse>;
    /**
     * exec runs the put request.
     */
    exec(): Promise<RPC.IPutResponse>;
}
